import logging
import re

from django.conf import settings
from django.db.models import Min
from django.db.models.functions import TruncDate
from django.utils import timezone
from operator import itemgetter

from app.models import (
    Container, Error, ErrorType, FullnessValues, Temperature, Pressure, Location, SimBalance, Battery_Level, Humidity,
    AirQuality, FullnessStats, RoutePoints, ROUTE_STATUS_STARTED_BY_USER, ROUTE_STATUS_MOVING_HOME, Collection,
)
from apps.trashbins.models import TrashReceiverStatistic


logger = logging.getLogger('app_main')


def is_trashbin_data_with_satellites(msg):
    version_parts = str(msg['version']).split('-')
    flavor = version_parts[1] if len(version_parts) > 1 else None
    return flavor == 'multi' and 'bins' in msg


def _update_container_fullness_stats(container, new_fullness_before_press, new_fullness_after_press, created):
    # Looking for an existing entry
    fullness_before_press, fullness_after_press = 0, 0
    existing_stats = FullnessStats.objects.filter(container=container, actual=1).first()
    if existing_stats:
        fullness_before_press, fullness_after_press = \
            existing_stats.fullness_before_press, existing_stats.fullness_after_press

    # In case there's no existing record or bin was collected recently
    if fullness_before_press == 0 and fullness_after_press == 0:
        fullness_before_press = new_fullness_before_press
    else:
        fullness_diff = new_fullness_before_press - new_fullness_after_press
        if fullness_diff <= 0:
            logger.warning(f"Negative or zero before press fullness diff for fullness after {new_fullness_after_press} "
                           f"at {created}.")
            return
        fullness_before_press = fullness_before_press + fullness_diff
    fullness_after_press = new_fullness_after_press

    FullnessStats.objects.filter(container=container, actual=1).update(actual=0)
    FullnessStats.objects.create(start_time=created, container=container, fullness_before_press=fullness_before_press,
                                 fullness_after_press=fullness_after_press)


def _generate_time_series_record(model, container, **kwargs):
    model.objects.filter(container=container, actual=1).update(actual=0)
    model.objects.create(container=container, actual=1, **kwargs)


def _trashbin_collection(container, created, use_stats):
    fullness_before_press, fullness_after_press = 0, 0

    if use_stats:
        existing_stats = FullnessStats.objects.filter(container=container, actual=1).first()
        if existing_stats:
            fullness_before_press, fullness_after_press = \
                existing_stats.fullness_before_press, existing_stats.fullness_after_press

    if fullness_before_press == 0 and fullness_after_press == 0:
        # This likely means there's no press stats for the bin - use raw fullness
        fullness_record = \
            FullnessValues.objects.filter(container=container).order_by('-actual', '-ctime', '-id').first()
        if fullness_record:
            fullness_before_press, fullness_after_press = fullness_record.fullness_value, fullness_record.fullness_value

    # get driver_id
    driver_id, route_point_id = None, None
    route_statuses = [ROUTE_STATUS_STARTED_BY_USER, ROUTE_STATUS_MOVING_HOME]
    point = RoutePoints.objects.filter(container=container, route__status__in=route_statuses).order_by('-id').first()
    if point:
        driver_id, route_point_id = point.user.id, point.id

    Collection.objects.create(ctime=created, fullness_before_press=fullness_before_press, fullness=fullness_after_press,
                              container=container, driver_id=driver_id, location=container.location,
                              route_point_id=route_point_id)

    if not use_stats:
        return

    FullnessStats.objects.filter(container=container, actual=1).update(actual=0, collection_time=timezone.now())
    FullnessStats.objects.create(start_time=created, container=container)


# TODO: Remove this blacklist when trashbin errors generation will be fixed
_error_type_codes_blacklist = [
    '20',
    '23',
    '24',
]


def _parse_master_bin_data(data, container_id, autogenerated):
    sorted_data = sorted(data, key=itemgetter('ctime'))
    bin_filling_before_list = sorted(
        [v for v in sorted_data if 'binFillingBefore' in v], key=itemgetter('ctime'), reverse=True)
    bin_filling_list = sorted(
        [v for v in sorted_data if 'binFilling' in v], key=itemgetter('ctime'), reverse=True)

    trashbin = Container.objects.get(pk=container_id)
    # Dropping current actual errors to free room for new ones
    Error.objects.filter(container=trashbin, actual=1).update(actual=0)
    for value_data in sorted_data:
        logger.debug("Parsing value in master bin data " + repr(value_data))

        value = value_data[0] if isinstance(value_data, list) else value_data
        location = value['location'] if 'location' in value else trashbin.location

        if 'Error' in value:
            errorsearch = re.compile(r"(\d+)")
            error_code = None
            if errorsearch.search(value['Error']):
                error_code = errorsearch.search(value['Error']).group(0)
            if error_code is not None:
                try:
                    error_type = ErrorType.objects.get(code=error_code)
                except ErrorType.DoesNotExist:
                    logger.warning(f"Failed to find error type with code '{error_code}'.")
                else:
                    if error_type.code in _error_type_codes_blacklist and not autogenerated:
                        logger.warning(f"Error type with code '{error_code}' is blacklisted.")
                    else:
                        # Created error will be actual by default
                        Error.objects.create(container=trashbin, error_type=error_type, ctime=value['ctime'])
        elif 'binFillingAfter' in value:
            earlier_bin_filling_before = [v for v in bin_filling_before_list if value['ctime'] > v['ctime']]
            bin_filling_before = earlier_bin_filling_before[0] if len(earlier_bin_filling_before) > 0 else None
            if bin_filling_before:
                fullness_before_press = round(bin_filling_before['binFillingBefore'])
                fullness_after_press = round(value['binFillingAfter'])
                _update_container_fullness_stats(
                    trashbin, fullness_before_press, fullness_after_press, value['ctime'])
            else:
                logger.warning(
                    f"Missing filling before for filling after '{str(value['binFillingAfter'])}' at {value['ctime']}")
        elif 'sensorTemperature' in value:
            temperature = value['sensorTemperature']
            trashbin.temperature = temperature
            _generate_time_series_record(
                Temperature, trashbin, temperature_value=temperature, ctime=value['ctime'], location=location)
        elif 'sensorPressure' in value:
            pressure = value['sensorPressure']
            pressure_mm = round(float(pressure) * 0.750062)
            trashbin.pressure = pressure_mm
            _generate_time_series_record(
                Pressure, trashbin, pressure_value=pressure_mm, ctime=value['ctime'], location=location)
        elif 'location' in value:
            latlong = ' '.join(reversed(value['location'].split()))
            updated_location = f"SRID=4326;POINT ({latlong})"
            trashbin.location = updated_location
            _generate_time_series_record(Location, trashbin, ctime=value['ctime'], location=updated_location)
        elif 'simBalance' in value:
            logger.debug("got SIM balance text: " + str(value['simBalance']))
            sms_text = value['simBalance']
            sim_balance_saved = False
            if sms_text is not None:
                nums = re.compile(r"[+-]?\d+(?:\.\d+)")
                if nums.search(sms_text):
                    sim_balance = int(float(nums.search(sms_text).group(0)))
                    logger.debug("Parsed SIM balance is: " + str(sim_balance))
                    _generate_time_series_record(SimBalance, trashbin, balance=sim_balance, ctime=value['ctime'])
                    sim_balance_saved = True
            if not sim_balance_saved:
                logger.warning("SIM balance received wasn't saved")
        elif 'batteryVoltage' in value:
            min_voltage, max_voltage = settings.ACCUM_MIN_VOLTAGE, settings.ACCUM_MAX_VOLTAGE
            percents = round((float(value['batteryVoltage']) - min_voltage) / ((max_voltage - min_voltage) / 100))
            clamped_percents = max(min(percents, 100), 0)
            trashbin.battery = clamped_percents
            _generate_time_series_record(
                Battery_Level, trashbin, level=clamped_percents, volts=value['batteryVoltage'], ctime=value['ctime'])
        elif 'rev_first' in value and 'rev_last' in value:
            pass
        elif 'trashReceiver_switchCounter_binFilling' in value:
            _trashbin_collection(trashbin, value['ctime'], True)
        # Traffic report was disabled since its absolutely fake at the moment
        # This code branch isn't supported by real trashbin yet, so can only leveraged by fake data generators
        # elif '_sensorTraffic_' in value:
        #     traffic = value['_sensorTraffic_']
        # trashbin.traffic = traffic
        # _generate_time_series_record(
        #     Traffic, trashbin, traffic_value=traffic, ctime=value['ctime'], location=location)
        elif 'sensorHumidity' in value:
            humidity = max(min(value['sensorHumidity'], 100), 0)
            trashbin.humidity = humidity
            _generate_time_series_record(
                Humidity, trashbin, humidity_value=humidity, ctime=value['ctime'], location=location)
        elif 'sensorAirQuality' in value:
            air_quality = round(float(value['sensorAirQuality']) / 1000)
            trashbin.air_quality = air_quality
            _generate_time_series_record(
                AirQuality, trashbin, air_quality_value=air_quality, ctime=value['ctime'], location=location)
        elif 'telNbr' in value:
            trashbin.phone_number = str(value['telNbr'])[:40]
        elif 'trashReceiver_switchCounter' in value:
            trash_recv_open_count = int(value['trashReceiver_switchCounter'])
            if trash_recv_open_count > 0:
                TrashReceiverStatistic.objects.filter(trashbin=trashbin, actual=True).update(actual=False)
                TrashReceiverStatistic.objects.create(
                    trashbin=trashbin, actual=True, open_count=trash_recv_open_count, ctime=value['ctime'])
    bin_filling_value = bin_filling_before_list[0] if len(bin_filling_before_list) > 0 else None
    if bin_filling_value is None and len(bin_filling_list) > 0:
        bin_filling_value = bin_filling_list[0]
    if bin_filling_value:
        filling = round(bin_filling_value['binFillingBefore'] if 'binFillingBefore' in bin_filling_value
                        else bin_filling_value['binFilling'])
        location = bin_filling_value['location'] if 'location' in bin_filling_value else trashbin.location
        trashbin.fullness = filling
        _generate_time_series_record(
            FullnessValues, trashbin, fullness_value=filling, ctime=bin_filling_value['ctime'], location=location)
    trashbin.data_mtime = timezone.now()
    trashbin.save()


def _parse_satellite_bin_data(data, container_id):
    sorted_data = sorted(data, key=itemgetter('ctime'))

    trashbin = Container.objects.get(pk=container_id)
    for value_data in sorted_data:
        logger.debug("Parsing value in satellite bin data " + repr(value_data))

        value = value_data[0] if isinstance(value_data, list) else value_data
        location = value['location'] if 'location' in value else trashbin.location

        if 'binFilling' in value:
            filling = round(value['binFilling'])
            collection_lower_bound, collection_upper_bound, stat_days = 10, 20, 3
            if filling < collection_lower_bound:
                daily_stats = FullnessValues.objects.filter(container=trashbin).annotate(date=TruncDate('ctime'))\
                    .values('date').order_by('-date').annotate(fullness_min=Min('fullness_value'))\
                    .values_list('date', 'fullness_min')[:stat_days]
                if all((day_stat[1] > collection_upper_bound for day_stat in daily_stats)):
                    _trashbin_collection(trashbin, value['ctime'], False)
            # It's important to update fullness after revision since without stats it uses current fullness
            trashbin.fullness = filling
            _generate_time_series_record(
                FullnessValues, trashbin, fullness_value=filling, ctime=value['ctime'], location=location)
    trashbin.data_mtime = timezone.now()
    trashbin.save()


def parse_trashbin_data_packet(msg, container_id):
    # msg is assumed to be mostly valid at this point
    logger.debug("Got data from a trashbin to parse " + repr(msg))

    _parse_master_bin_data(msg['data'], container_id, 'autogenerated' in msg)

    if is_trashbin_data_with_satellites(msg):
        satellite_ids = []
        for satellite_msg in msg['bins']:
            satellite_serial = str(satellite_msg['serial'])
            try:
                satellite = Container.objects.get(serial_number=satellite_serial)
            except Container.DoesNotExist:
                logger.warning(f"Satellite with serial '{satellite_serial}'")
            else:
                _parse_satellite_bin_data(satellite_msg['data'], satellite.id)
                satellite_ids.append(satellite.id)
        if len(satellite_ids) > 0:
            Container.objects.filter(pk__in=satellite_ids).update(master_bin=container_id)
